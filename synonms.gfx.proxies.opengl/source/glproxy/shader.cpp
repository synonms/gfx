#include "shader.h"

#include <GL\glew.h>

#include <glproxy\error.h>

using namespace synonms::gfx::proxies::opengl;
using namespace synonms::gfx::proxies::opengl::enumerators;

bool Shader::Compile(unsigned int shaderId, bool throwOnError)
{
    if (throwOnError) Error::Clear();

    glCompileShader(shaderId);

    if (throwOnError) Error::ThrowIf({
        {GL_INVALID_VALUE, "ShaderId is not a value generated by OpenGL." },
        {GL_INVALID_OPERATION , "ShaderId is not a shader object." }
        });

    int result;
    glGetShaderiv(shaderId, GL_COMPILE_STATUS, &result);

    return result == GL_TRUE;
}

unsigned int Shader::Create(ShaderType shaderType, bool throwOnError)
{
    if (throwOnError) Error::Clear();

    auto shaderId = glCreateShader(static_cast<unsigned int>(shaderType));

    if (throwOnError) Error::ThrowIf({
        {GL_INVALID_ENUM , "ShaderType is invalid." }
        });

    return shaderId;
}

void Shader::Delete(unsigned int shaderId, bool throwOnError)
{
    if (throwOnError) Error::Clear();

    glDeleteShader(shaderId);

    if (throwOnError) Error::ThrowIf({
        {GL_INVALID_VALUE, "ShaderId is not a value generated by OpenGL." }
        });
}

std::string Shader::GetLog(unsigned int shaderId)
{
    int length;
    glGetShaderiv(shaderId, GL_INFO_LOG_LENGTH, &length);

    char* message = (char*)alloca(length * sizeof(char));
    glGetShaderInfoLog(shaderId, length, &length, message);

    return message;
}

void Shader::SetSource(unsigned int shaderId, const std::string& sourceCode, bool throwOnError)
{
    if (throwOnError) Error::Clear();

    auto sourceData = sourceCode.c_str();

    glShaderSource(shaderId, 1, &sourceData, nullptr);

    if (throwOnError) Error::ThrowIf({
        {GL_INVALID_VALUE, "ShaderId is not a value generated by OpenGL OR Count is less than 0." },
        {GL_INVALID_OPERATION , "ShaderId is not a shader object." },
        });
}

